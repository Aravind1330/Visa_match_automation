import dash
from dash import dcc, html
import dash_bootstrap_components as dbc
import dash_table
from dash.dependencies import Input, Output
import pandas as pd
import base64

# Load your actual Excel sheet here
# Replace 'your_excel_file.xlsx' with your file path
excel_path = 'your_excel_file.xlsx'
df = pd.read_excel(excel_path)

# Create Dash app
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Role dropdown with additional values
roleSelect = dcc.Dropdown(
    options=[
        {'label': 'Test Role', 'value': 'Test Role'},
        {'label': 'Role A', 'value': 'Role A'},
        {'label': 'Role B', 'value': 'Role B'},
    ],
    value='Test Role',
    id='role-dropdown',
    placeholder='Select the role',
    style=dict(width=400)
)

######################### cards #####################################
card_icon = {
    'color': 'white',
    "textAlign": "center",
    "fontSize": 40,
    "margin": "auto"
}

# Role card
role = dbc.Card(
    dbc.CardGroup(
        [
            dbc.Card(
                dbc.CardBody(
                    [
                        html.H6('JOB ID-Role', className='card-title text-center', style={'fontSize': 20}),
                        html.H5(className='display-6 text-center', style={'fontSize': '1.5rem', 'fontWeight': 600},
                                id='role-card')
                    ]
                )
            ),
            dbc.Card(
                html.Div(className='fas fa-id-card', style=card_icon),
                style={'maxWidth': '30%', 'backgroundColor': '#767B88'}
            )
        ], style={'outline-width': '1px', 'outline-color': '#5A5A5A'}
    )
)

# Requirements card
req = dbc.Card(
    dbc.CardGroup(
        [
            dbc.Card(
                dbc.CardBody(
                    [
                        html.H6('Openings', className='card-title text-center', style={'fontSize': 20}),
                        html.H3('5', className='display-6 text-center', style={'fontSize': 25})
                    ]
                ),
            ),
            dbc.Card(
                html.Div(className='fas fa-hashtag', style=card_icon),
                style={'maxWidth': '30%', 'backgroundColor': '#767B88'}
            )
        ], style={'outline-width': '1px', 'outline-color': '#5A5A5A'}
    )
)

# Number of applications card
applications = dbc.Card(
    dbc.CardGroup(
        [
            dbc.Card(
                dbc.CardBody(
                    [
                        html.H6('Candidates Applied', className='card-title text-center', style={'fontSize': 20}),
                        html.H3(children='', className='display-6 text-center', style={'fontSize': 25}, id='cand-applied')
                    ]
                )
            ),
            dbc.Card(
                html.Div(className='fas fa-archive', style=card_icon),
                style={'maxWidth': '30%', 'backgroundColor': '#767B88'}
            )
        ], style={'outline-width': '1px', 'outline-color': '#5A5A5A'}
    )
)

# Layout with dbc.Container and dbc.Row
app.layout = dbc.Container(
    [
        dbc.Row(
            [
                dbc.Col(role, width=4, style={'padding-right': '6px', 'padding-left': '6px'}),
                dbc.Col(req, width=4, style={'padding-right': '6px', 'padding-left': '6px'}),
                dbc.Col(applications, width=4, style={'padding-right': '6px', 'padding-left': '6px'}),
            ], style={
                'margin-left': -12,
                'margin-right': -12,
                'margin-top': '10px',
                'padding-bottom': '0px',
                'margin-left': -12,
                'margin-right': -12,
            }
        ),

        # New Row for Excel Sheet
        dbc.Row(
            [
                dbc.Col(
                    html.Div(
                        [
                            html.H6('Excel Sheet Editing', className='card-title text-center', style={'fontSize': 20}),
                            dash_table.DataTable(
                                id='excel-sheet',
                                columns=[{'name': col, 'id': col} for col in df.columns],
                                data=df.to_dict('records'),
                                editable=True,
                                row_deletable=True,  # Enable row deletion
                                style_table={'overflowX': 'auto'},
                                style_cell={'textAlign': 'left'},
                            ),
                        ],
                        style={'margin': '20px'}
                    ),
                    width=12
                ),
            ]
        ),
    ]
)

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)









# Layout with dbc.Container and dbc.Row
app.layout = dbc.Container(
    [
        dbc.Row(
            [
                dbc.Col(role, width=4, style={'padding-right': '6px', 'padding-left': '6px'}),
                dbc.Col(req, width=4, style={'padding-right': '6px', 'padding-left': '6px'}),
                dbc.Col(applications, width=4, style={'padding-right': '6px', 'padding-left': '6px'}),
            ], style={
                'margin-left': -12,
                'margin-right': -12,
                'margin-top': '10px',
                'padding-bottom': '0px',
                'margin-left': -12,
                'margin-right': -12,
            }
        ),

        # New Row for Excel Sheet
        dbc.Row(
            [
                dbc.Col(
                    html.Div(
                        [
                            html.H6('Excel Sheet Editing', className='card-title text-center', style={'fontSize': 15}),
                            dbc.Card(
                                dbc.CardBody(
                                    [
                                        dash_table.DataTable(
                                            id='excel-sheet',
                                            columns=[{'name': col, 'id': col} for col in df.columns],
                                            data=df.to_dict('records'),
                                            editable=True,
                                            row_deletable=True,  # Enable row deletion
                                            style_table={'overflowX': 'auto'},
                                            style_cell={'textAlign': 'left'},
                                        ),
                                    ],
                                ),
                                style={'height': '300px', 'overflowY': 'auto', 'border': '1px solid #ddd', 'padding': '10px'}
                            ),
                            html.Button('Edit', id='edit-button', n_clicks=0, style={'margin': '10px'}),
                            html.Button('Save', id='save-button', n_clicks=0, style={'margin': '10px'}),
                            dcc.Download(id='download-csv'),
                        ],
                        style={'margin': '20px'}
                    ),
                    width=12
                ),
            ]
        ),
    ]
)

# Callback to handle editing, saving, and downloading CSV
@app.callback(
    Output('excel-sheet', 'editable'),
    Output('download-csv', 'data'),
    Input('edit-button', 'n_clicks'),
    Input('save-button', 'n_clicks'),
    State('excel-sheet', 'editable'),
    prevent_initial_call=True
)
def handle_edit_save_download(edit_clicks, save_clicks, is_editable):
    ctx = dash.callback_context
    button_id = ctx.triggered_id

    if button_id == 'edit-button':
        # Toggle editable property on Edit button click
        return not is_editable, dash.no_update
    elif button_id == 'save-button':
        # Save the changes to CSV on Save button click
        if is_editable:
            # Get the edited data from the table
            edited_df = pd.DataFrame(ctx.states['excel-sheet.data'])
            
            # Save the edited data to a CSV file
            edited_df.to_csv('edited_data.csv', index=False, encoding='utf-8-sig')
            return dash.no_update, dict(content=base64.b64encode(edited_df.to_csv(index=False).encode()), filename='edited_data.csv')
    
    return dash.no_update, dash.no_update

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)






# Callback to update DataTable based on selected tab
@app.callback(
    Output('excel-sheet', 'data'),
    Output('excel-sheet', 'columns'),
    Input('tabs', 'value'),
)
def update_sheet(tab_value):
    if tab_value == 'data-sheet':
        return data_df.to_dict('records'), [{'name': col, 'id': col} for col in data_df.columns]
    elif tab_value == 'ml-sheet':
        return ml_df.to_dict('records'), [{'name': col, 'id': col} for col in ml_df.columns]
    else:
        return [], []

# Callback to handle editing, saving, and downloading CSV
@app.callback(
    Output('excel-sheet', 'editable'),
    Output('download-csv', 'data'),
    Input('edit-button', 'n_clicks'),
    Input('save-button', 'n_clicks'),
    State('excel-sheet', 'editable'),
    State('tabs', 'value'),
    prevent_initial_call=True
)
def handle_edit_save_download(edit_clicks, save_clicks, is_editable, selected_tab):
    ctx = dash.callback_context
    button_id = ctx.triggered_id

    if button_id == 'edit-button':
        # Toggle editable property on Edit button click
        return not is_editable, dash.no_update
    elif button_id == 'save-button':
        # Save the changes to CSV on Save button click
        if is_editable:
            # Get the edited data from the table
            edited_df = pd.DataFrame(ctx.states['excel-sheet.data'])

            # Save the edited data to a CSV file
            edited_df.to_csv('edited_data.csv', index=False, encoding='utf-8-sig')
            return dash.no_update, dict(content=base64.b64encode(edited_df.to_csv(index=False).encode()), filename='edited_data.csv')

    return dash.no_update, dash.no_update



def match_bundle(T5, Invoice_table):
    matching_invoices = []
    total_invoice_source_amt = 0
    match_rule = None

    for Invoice in Invoice_table:
        for rule_index, rule in enumerate(rules, start=1):
            if rule(T5, Invoice=Invoice):
                invoice_amt = float(Invoice['inv_match_source_amt'])
                remaining_amt = float(T5['fin_source_amt']) - total_invoice_source_amt

                matching_invoices.append((Invoice, rule_index))
                total_invoice_source_amt += invoice_amt
                Invoice_table.remove(Invoice)
                break  # Exit the inner loop after finding a match

        if total_invoice_source_amt == float(T5['fin_source_amt']):
            break

    if total_invoice_source_amt == float(T5['fin_source_amt']):
        return matching_invoices, match_rule
    else:
        return [], None
\




def match_bundle(T5, Invoice_table):
    matching_invoices = []
    total_invoice_source_amt = 0
    match_rule = None

    for Invoice in Invoice_table:
        for rule_index, rule in enumerate(rules, start=1):
            if rule(T5, Invoice=Invoice):
                invoice_amt = float(Invoice['inv_match_source_amt'])
                remaining_amt = float(T5['fin_source_amt']) - total_invoice_source_amt

                # Allow matches even if invoice_amt is greater than remaining_amt
                matching_invoices.append((Invoice, rule_index))
                total_invoice_source_amt += invoice_amt
                Invoice_table.remove(Invoice)
                break  # Exit the inner loop after finding a match

        if total_invoice_source_amt == float(T5['fin_source_amt']):
            break

    if total_invoice_source_amt == float(T5['fin_source_amt']):
        return matching_invoices, match_rule
    else:
        return [], None
