T5_table['Match Rule'] = pd.Series(["Unmatched"]*len(T5_table))
T5_table['Description'] = pd.Series([""]*len(T5_table))



Change the line T5_table.to_excel("Z:/Desktop/output2.xlsx", index=False) to T5_table.to_excel("Z:/Desktop/output2.xlsx", index=False, columns=['Company ID & Name', 'fin_orig_supplier_nm', 'fin_source_amt', 'Match Rule', 'Description']) to select only the specified columns for the output file.

Finally, change the line aggregated.to_excel(writer, sheet_name='Aggregated', index=False) to aggregated.to_excel(writer, sheet_name='Aggregated', index=False, columns=['Company ID & Name', 'Match Rule', 'Description', 'TRF']) to select only the specified columns for the aggregated data sheet in the output file.
for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5, Invoice)
        if matched:
            T5_table.at[i, 'Match Rule'] = rule_index
            break
    if not matched:
        T5_table.at[i, 'Match Rule'] = "Unmatched"





for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5.to_dict(), Invoice.to_dict())
        if matched:
            T5_table.at[i, 'Match Rule'] = rule_index
            break
    if not matched:
        T5_table.at[i, 'Match Rule'] = "Unmatched"














import pandas as pd

# Read the rules from a text file
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

# Remove new line characters and empty lines, and convert to list of functions
rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

# Define a function to apply the rules to each row pair and return the rule index
def match_row(T5, Invoice):
    for i, rule in enumerate(rules):
        if rule(T5, Invoice):
            return True, i+1
    return False, "Unmatched"

T5_table = pd.read_excel('Z:/Downloads/Unmatched_trans_Data_1.xlsx', dtype=str)
# Read in the second Excel sheet
Invoice_table = pd.read_excel('Z:/Downloads/Unmatched_Inv_Data_1.xlsx', dtype=str)

# Create an empty column for the match rule index and description in the output file
output_columns = ['Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no']
output_data = []
rule_descriptions = {
    1: 'Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same',
    2: 'Ticket_no_right_of_12'
}

# Loop through each row in table1 and find a match in table2
for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5.to_dict(), Invoice.to_dict())
        if matched:
            description = rule_descriptions[rule_index]
            output_data.append([T5['Company ID & Name'], rule_index, description, T5['fin_orig_supplier_nm'], T5['fin_source_amt'], Invoice['inv_match_source_amt'], Invoice['inv_erp_vend_no'], Invoice['inv_po_no']])
            break

# Write the output data to an Excel file
output_df = pd.DataFrame(output_data, columns=output_columns)
aggregated = output_df.groupby(['Company ID & Name', 'Match Rule']).size().reset_index(name='TRF')
total = aggregated['TRF'].sum()
aggregated = aggregated.append(pd.Series(['Total', '-', total], index=aggregated.columns), ignore_index=True)

with pd.ExcelWriter('Z:/Desktop/output2.xlsx') as writer:
    output_df.to_excel(writer, sheet_name='Output', index=False)
    aggregated.to_excel(writer, sheet_name='Aggregated', index=False)










    Import the pandas library with an alias pd.

python

import pandas as pd

    Open a text file containing the rules for matching.

python

with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

    Remove new line characters and empty lines from the rule strings, and convert them to a list of functions.

python

rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

This step reads the rules from the text file, removes any new line characters and empty lines, and converts each rule string into a function using the eval function.

    Define a function to apply the rules to each row pair and return the rule index.

python

def match_row(T5, Invoice):
    for i, rule in enumerate(rules):
        if rule(T5, Invoice):
            return True, i+1
    return False, "Unmatched"

This function takes two rows as input, applies the rules to them one by one, and returns a Boolean value indicating whether a match was found and the index of the matching rule.

    Read in the first Excel sheet into a pandas DataFrame called T5_table.

python

T5_table = pd.read_excel('Z:/Downloads/Unmatched_trans_Data_1.xlsx', dtype=str)

    Read in the second Excel sheet into a pandas DataFrame called Invoice_table.

python

Invoice_table = pd.read_excel('Z:/Downloads/Unmatched_Inv_Data_1.xlsx', dtype=str)

    Create an empty list called output_data to store the matched rows, and a dictionary called rule_descriptions to store the descriptions of the matching rules.

python

output_data = []
rule_descriptions = {
    1: 'Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same',
    2: 'Ticket_no_right_of_12'
}

    Loop through each row in T5_table, find a match in Invoice_table using the match_row function, and append the matched row along with the rule index and description to the output_data list.

python

for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5.to_dict(), Invoice.to_dict())
        if matched:
            description = rule_descriptions[rule_index]
            output_data.append([T5['Company ID & Name'], rule_index, description, T5['fin_orig_supplier_nm'], T5['fin_source_amt'], Invoice['inv_match_source_amt'], Invoice['inv_erp_vend_no'], Invoice['inv_po_no']])
            break

    Create a pandas DataFrame called output_df from the output_data list, add a column called "TRF" to store the number of rows matched for each company and rule, and write the output to an Excel file called output2.xlsx.

python

output_columns = ['Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no']
output_df = pd.DataFrame(output_data, columns=output_columns)
aggregated


The code performs a matching process between two Excel tables, T5_table and Invoice_table, and generates an output file with the matched rows along with a rule index and description. Here is a step-by-step explanation of the code:





    Test with sample input files: You can create small sample input Excel files with a few rows and columns and test the code to see if it produces the expected output.

    Test with different rule sets: You can create different rule sets in a text file and test the code with each rule set to see if it produces the expected output.

    Test with missing data: You can remove some data from the input files and test the code to see how it handles missing data.

    Test with different data types: You can test the code with input files that have different data types (e.g., integers, floats, dates, strings) to see if it handles them correctly.

    Test with larger input files: You can test the code with larger input files to see if it can handle them efficiently without crashing or running out of memory.

    Test with edge cases: You can test the code with edge cases, such as input files that have many duplicates, or rules that match only a small subset of the data, to see if it produces the expected output.

    Test with invalid input files: You can test the code with invalid input files, such as files that are not in the expected format, to see how it handles errors and exceptions.








from pyspark.sql import SparkSession
from pyspark.sql.functions import udf
from pyspark.sql.types import BooleanType, IntegerType, StringType
import pandas as pd

# Initialize SparkSession
spark = SparkSession.builder.appName("Matching").getOrCreate()

# Define UDFs to convert row dictionaries to DataFrame rows
row_dict_to_row = udf(lambda d: tuple(d.values()), StringType())
row_dict_to_row2 = udf(lambda d: tuple(d.values()), StringType())

# Read the rules from a text file
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

# Remove new line characters and empty lines, and convert to list of functions
rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

# Define a UDF to apply the rules to each row pair and return the rule index
match_row_udf = udf(lambda T5, Invoice: match_row(T5, Invoice, rules), (BooleanType(), IntegerType()))

# Define a function to apply the rules to each row pair and return the rule index
def match_row(T5, Invoice, rules):
    for i, rule in enumerate(rules):
        if rule(T5, Invoice):
            return True, i+1
    return False, "Unmatched"

# Read in the two Excel sheets as PySpark DataFrames
T5_table = spark.read.format("com.crealytics.spark.excel") \
    .option("header", "true") \
    .option("inferSchema", "true") \
    .option("dataAddress", "'Sheet1$'") \
    .load("Z:/Downloads/Unmatched_trans_Data_1.xlsx")
Invoice_table = spark.read.format("com.crealytics.spark.excel") \
    .option("header", "true") \
    .option("inferSchema", "true") \
    .option("dataAddress", "'Sheet1$'") \
    .load("Z:/Downloads/Unmatched_Inv_Data_1.xlsx")

# Apply the UDF to each row pair and select the matching rows
matched_rows = T5_table.crossJoin(Invoice_table) \
    .withColumn("matched", match_row_udf(row_dict_to_row(T5_table), row_dict_to_row2(Invoice_table))) \
    .filter("matched[0] == true") \
    .select(T5_table["Company ID & Name"], "matched[1]", T5_table["fin_orig_supplier_nm"], T5_table["fin_source_amt"], Invoice_table["inv_match_source_amt"], Invoice_table["inv_erp_vend_no"], Invoice_table["inv_po_no"])

# Create a Pandas DataFrame from the matched rows
output_df = matched_rows.toPandas()

# Add a column for the rule description
output_df["description"] = output_df["matched[1]"].map({1: "Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same", 2: "Ticket_no_right_of_12"})

# Group the output by Company ID & Name and Match Rule and count the number of rows
aggregated = output_df.groupby(["Company ID & Name", "matched[1]"]).size().reset_index(name="TRF")
total = aggregated["TRF"].sum()

# Add a row for the total
aggregated = aggregated.append(pd.Series(["Total", "-", total], index=










import pandas as pd

# Read the rules from a text file
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

# Remove new line characters and empty lines, and convert to dictionary of functions
rules = {}
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules[len(rules) + 1] = rule

# Define a function to apply the rules to each row pair and return the rule index
def match_row(T5, Invoice):
    for i, rule in rules.items():
        if rule(T5, Invoice):
            return True, i
    return False, 0

# Define the columns that are required for the matching and output
T5_columns = ['Company ID & Name', 'fin_orig_supplier_nm', 'fin_source_amt']
Invoice_columns = ['inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no']

# Read in the Excel sheets and select the required columns
T5_table = pd.read_excel('Z:/Downloads/Unmatched_trans_Data_1.xlsx', dtype=str, usecols=T5_columns)
Invoice_table = pd.read_excel('Z:/Downloads/Unmatched_Inv_Data_1.xlsx', dtype=str, usecols=Invoice_columns)

# Loop through each row in table1 and find a match in table2
output_data = []
rule_descriptions = {
    1: 'Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same',
    2: 'Ticket_no_right_of_12'
}

for i, T5_row in T5_table.iterrows():
    T5 = T5_row.to_dict()
    matches = Invoice_table.apply(lambda row: match_row(T5, row.to_dict()), axis=1)
    matched_indices = matches[matches.apply(lambda x: x[0])].index.tolist()
    for index in matched_indices:
        Invoice = Invoice_table.loc[index].to_dict()
        rule_index = matches.loc[index][1]
        description = rule_descriptions[rule_index]
        output_data.append([T5['Company ID & Name'], rule_index, description, T5['fin_orig_supplier_nm'], T5['fin_source_amt'], Invoice['inv_match_source_amt'], Invoice['inv_erp_vend_no'], Invoice['inv_po_no']])

# Create a data frame from the output data and group by company and rule
output_df = pd.DataFrame(output_data, columns=['Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no'])
aggregated = output_df.groupby(['Company ID & Name', 'Match Rule']).size().reset_index(name='TRF')
total = aggregated['TRF'].sum()
aggregated = aggregated.append(pd.Series(['Total', '-', total], index=aggregated.columns), ignore_index=True)

# Write the output data to an Excel file
with pd.ExcelWriter





import time

start_time = time.time()

# Your code goes here

end_time = time.time()

print("Runtime: {} seconds".format(end_time - start_time))












import pandas as pd

# Read the rules from a text file
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

# Remove new line characters and empty lines, and convert to list of functions
rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

# Define a function to apply the rules to each row pair and return the rule index
def match_rows(T5, Invoice):
    return [rule(T5, Invoice) for rule in rules]

T5_table = pd.read_excel('Z:/Downloads/Unmatched_trans_Data_1.xlsx', dtype=str)
# Read in the second Excel sheet
Invoice_table = pd.read_excel('Z:/Downloads/Unmatched_Inv_Data_1.xlsx', dtype=str)

# Create an empty column for the match rule index and description in the output file
output_columns = ['Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no']
output_data = []
rule_descriptions = {
    1: 'Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same',
    2: 'Ticket_no_right_of_12'
}

# Apply the matching function to all row pairs using vectorization
matched = pd.DataFrame(index=T5_table.index, columns=Invoice_table.index)
for i, T5 in T5_table.iterrows():
    matched.iloc[i] = match_rows(T5.to_dict(), Invoice_table.to_dict(orient='records'))

# Find the first matching rule index for each T5 row
match_indices = matched.idxmax(axis=1).astype(int)

# Create the output data by combining T5 and Invoice data based on the matching indices
matched_rows = pd.concat([T5_table, Invoice_table.iloc[match_indices]], axis=1)
matched_rows['Match Rule'] = match_indices.apply(lambda x: x if x>0 else 'Unmatched')
matched_rows['description'] = matched_rows['Match Rule'].map(rule_descriptions)
output_data = matched_rows[output_columns].values.tolist()

# Write the output data to an Excel file
output_df = pd.DataFrame(output_data, columns=output_columns)
aggregated = output_df.groupby(['Company ID & Name', 'Match Rule']).size().reset_index(name='TRF')
total = aggregated['TRF'].sum()
aggregated = aggregated.append(pd.Series(['Total', '-', total], index=aggregated.columns), ignore_index=True)

with pd.ExcelWriter('Z:/Desktop/output2.xlsx') as writer:
    output_df.to_excel(writer, sheet_name='Output', index=False)
    aggregated.to_excel(writer, sheet_name='Aggregated', index=False)





import pandas as pd

# Read the rules from a text file
rules = {}
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    for i, rule_string in enumerate(f):
        rule_string = rule_string.strip()
        if rule_string:
            rule = eval(f"lambda row, row2: {rule_string}")
            rules[i+1] = {'rule': rule, 'description': rule_string}

# Define a function to apply the rules to each row pair and return the rule index
def match_row(T5, Invoice):
    for i, rule_data in rules.items():
        if rule_data['rule'](T5, Invoice):
            return True, i, rule_data['description']
    return False, 0, "Unmatched"

T5_table = pd.read_excel('Z:/Downloads/Unmatched_trans_Data_1.xlsx', dtype=str)
# Read in the second Excel sheet
Invoice_table = pd.read_excel('Z:/Downloads/Unmatched_Inv_Data_1.xlsx', dtype=str)

# Create an empty column for the match rule index and description in the output file
output_columns = ['Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no']
output_data = []

# Loop through each row in table1 and find a match in table2
for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index, description = match_row(T5.to_dict(), Invoice.to_dict())
        if matched:
            output_data.append([T5['Company ID & Name'], rule_index, description, T5['fin_orig_supplier_nm'], T5['fin_source_amt'], Invoice['inv_match_source_amt'], Invoice['inv_erp_vend_no'], Invoice['inv_po_no']])
            break

# Write the output data to an Excel file
output_df = pd.DataFrame(output_data, columns=output_columns)
aggregated = output_df.groupby(['Company ID & Name', 'Match Rule']).size().reset_index(name='TRF')
total = aggregated['TRF'].sum()
aggregated = aggregated.append(pd.Series(['Total', '-', total], index=aggregated.columns), ignore_index=True)

with pd.ExcelWriter('Z:/Desktop/output2.xlsx') as writer:
    output_df.to_excel(writer, sheet_name='Output', index=False)
    aggregated.to_excel(writer, sheet_name='Aggregated', index=False)





# Loop through each row in table1 and find a match in table2
for T5 in T5_table.itertuples(index=False):
    matched = False
    for Invoice in Invoice_table.itertuples(index=False):
        matched, rule_index, description = match_row(T5._asdict(), Invoice._asdict())
        if matched:
            output_data.append([T5[0], rule_index, description, T5[3], T5[4], Invoice[2], Invoice[3], Invoice[1]])
            break




# Import required libraries and create SparkSession object
from pyspark.sql.functions import udf
from pyspark.sql.types import *
from pyspark.sql import SparkSession

spark = SparkSession.builder.appName("MatchData").getOrCreate()

# Read input Excel files as Spark dataframes and create temporary views
T5_table = spark.read.format('excel').option('header', 'true').load('Z:/Downloads/Unmatched_trans_Data_1.xlsx')
T5_table.createOrReplaceTempView("T5_table")

Invoice_table = spark.read.format('excel').option('header', 'true').load('Z:/Downloads/Unmatched_Inv_Data_1.xlsx')
Invoice_table.createOrReplaceTempView("Invoice_table")

# Define UDF to implement matching rules
def match_row_udf(T5_dict, Invoice_dict):
    # Define matching rules using T5_dict and Invoice_dict
    # Return match rule index or 'Unmatched' string
    for i, rule in enumerate(rules):
        if rule(T5_dict, Invoice_dict):
            return i+1
    return 'Unmatched'

# Convert UDF to Spark UDF and register with Spark
match_row_spark_udf = udf(match_row_udf, StringType())
spark.udf.register("match_row", match_row_spark_udf)

# Perform join operation using UDF and select required columns
output_df = spark.sql("""
    SELECT 
        T5_table.`Company ID & Name`, 
        match_row(T5_table, Invoice_table) as `Match Rule`, 
        CASE match_row(T5_table, Invoice_table)
            WHEN 1 THEN 'Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same'
            WHEN 2 THEN 'Ticket_no_right_of_12'
            ELSE 'Unmatched'
        END as `description`,
        T5_table.`fin_orig_supplier_nm`, 
        T5_table.`fin_source_amt`, 
        Invoice_table.`inv_match_source_amt`, 
        Invoice_table.`inv_erp_vend_no`, 
        Invoice_table.`inv_po_no`
    FROM T5_table 
    JOIN Invoice_table 
    WHERE match_row(T5_table, Invoice_table) != 'Unmatched'
""")

# Aggregate output dataframe and write to Excel file
aggregated = output_df.groupBy('Company ID & Name', 'Match Rule').count().withColumnRenamed('count', 'TRF')
total = aggregated.select('TRF').rdd.map(lambda x: x[0]).sum()
aggregated = aggregated.union(spark.createDataFrame([['Total', '-', total]], output_columns))
aggregated = aggregated.withColumn('Match Rule', aggregated['Match Rule'].cast(StringType()))
output_df = output_df.withColumn('Match Rule', output_df['Match Rule'].cast(StringType()))

output_df.write.format('excel').option('header', 'true').save('Z:/Desktop/output














import pyspark.sql.functions as F
from pyspark.sql import SparkSession

# Create a SparkSession
spark = SparkSession.builder.appName('Matching').getOrCreate()

# Read the rules from a text file
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

# Remove new line characters and empty lines, and convert to list of functions
rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

# Define a function to apply the rules to each row pair and return the rule index
def match_row(T5, Invoice):
    for i, rule in enumerate(rules):
        if rule(T5, Invoice):
            return i+1
    return 0

# Read the data into Spark DataFrames
T5_df = spark.read.format('csv').option('header', True).option('inferSchema', True).load('Z:/Downloads/Unmatched_trans_Data_1.xlsx')
Invoice_df = spark.read.format('csv').option('header', True).option('inferSchema', True).load('Z:/Downloads/Unmatched_Inv_Data_1.xlsx')

# Add a column to T5_df for each rule, indicating whether the row matches the rule
for i, rule in enumerate(rules):
    udf_match_row = F.udf(lambda row: match_row(row, Invoice_df.collect()), returnType=IntegerType())
    T5_df = T5_df.withColumn(f'rule_{i+1}', udf_match_row(F.struct([T5_df[col] for col in T5_df.columns])))

# Join T5_df and Invoice_df on the rule columns
join_cols = [f'rule_{i+1}' for i in range(len(rules))]
joined_df = T5_df.join(Invoice_df, join_cols)

# Filter out rows where no rule matches
matched_df = joined_df.filter(F.col('rule_1') + F.col('rule_2') > 0)

# Add columns for the rule index and description to the matched DataFrame
udf_rule_description = F.udf(lambda rule_index: rule_descriptions.get(rule_index, 'Unmatched'), returnType=StringType())
matched_df = matched_df.withColumn('Match Rule', F.greatest(*join_cols)).withColumn('description', udf_rule_description(F.greatest(*join_cols)))

# Select the columns we want in the output DataFrame
output_df = matched_df.select('Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no')

# Write the output data to an Excel file
output_df.toPandas().to_excel('Z:/Desktop/output2.xlsx', index=False)

# Aggregate the output data by Company ID & Name and Match Rule
aggregated = output_df.groupBy('Company ID & Name', 'Match Rule').count().withColumnRenamed('count', 'TRF')
total = aggregated.agg(F.sum('TRF')).collect()[0][0]
aggregated = aggregated.union(spark.createDataFrame([('Total', '-', total)], ['Company ID & Name', 'Match Rule', 'TRF']))

# Write the aggregated data to a separate sheet in the output file
aggregated.toPandas().to_excel('Z:/Desktop/output2.xlsx', sheet_name='Aggregated', index=False)
