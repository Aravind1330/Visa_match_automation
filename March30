T5_table['Match Rule'] = pd.Series(["Unmatched"]*len(T5_table))
T5_table['Description'] = pd.Series([""]*len(T5_table))



Change the line T5_table.to_excel("Z:/Desktop/output2.xlsx", index=False) to T5_table.to_excel("Z:/Desktop/output2.xlsx", index=False, columns=['Company ID & Name', 'fin_orig_supplier_nm', 'fin_source_amt', 'Match Rule', 'Description']) to select only the specified columns for the output file.

Finally, change the line aggregated.to_excel(writer, sheet_name='Aggregated', index=False) to aggregated.to_excel(writer, sheet_name='Aggregated', index=False, columns=['Company ID & Name', 'Match Rule', 'Description', 'TRF']) to select only the specified columns for the aggregated data sheet in the output file.
for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5, Invoice)
        if matched:
            T5_table.at[i, 'Match Rule'] = rule_index
            break
    if not matched:
        T5_table.at[i, 'Match Rule'] = "Unmatched"





for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5.to_dict(), Invoice.to_dict())
        if matched:
            T5_table.at[i, 'Match Rule'] = rule_index
            break
    if not matched:
        T5_table.at[i, 'Match Rule'] = "Unmatched"














import pandas as pd

# Read the rules from a text file
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

# Remove new line characters and empty lines, and convert to list of functions
rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

# Define a function to apply the rules to each row pair and return the rule index
def match_row(T5, Invoice):
    for i, rule in enumerate(rules):
        if rule(T5, Invoice):
            return True, i+1
    return False, "Unmatched"

T5_table = pd.read_excel('Z:/Downloads/Unmatched_trans_Data_1.xlsx', dtype=str)
# Read in the second Excel sheet
Invoice_table = pd.read_excel('Z:/Downloads/Unmatched_Inv_Data_1.xlsx', dtype=str)

# Create an empty column for the match rule index and description in the output file
output_columns = ['Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no']
output_data = []
rule_descriptions = {
    1: 'Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same',
    2: 'Ticket_no_right_of_12'
}

# Loop through each row in table1 and find a match in table2
for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5.to_dict(), Invoice.to_dict())
        if matched:
            description = rule_descriptions[rule_index]
            output_data.append([T5['Company ID & Name'], rule_index, description, T5['fin_orig_supplier_nm'], T5['fin_source_amt'], Invoice['inv_match_source_amt'], Invoice['inv_erp_vend_no'], Invoice['inv_po_no']])
            break

# Write the output data to an Excel file
output_df = pd.DataFrame(output_data, columns=output_columns)
aggregated = output_df.groupby(['Company ID & Name', 'Match Rule']).size().reset_index(name='TRF')
total = aggregated['TRF'].sum()
aggregated = aggregated.append(pd.Series(['Total', '-', total], index=aggregated.columns), ignore_index=True)

with pd.ExcelWriter('Z:/Desktop/output2.xlsx') as writer:
    output_df.to_excel(writer, sheet_name='Output', index=False)
    aggregated.to_excel(writer, sheet_name='Aggregated', index=False)










    Import the pandas library with an alias pd.

python

import pandas as pd

    Open a text file containing the rules for matching.

python

with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

    Remove new line characters and empty lines from the rule strings, and convert them to a list of functions.

python

rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

This step reads the rules from the text file, removes any new line characters and empty lines, and converts each rule string into a function using the eval function.

    Define a function to apply the rules to each row pair and return the rule index.

python

def match_row(T5, Invoice):
    for i, rule in enumerate(rules):
        if rule(T5, Invoice):
            return True, i+1
    return False, "Unmatched"

This function takes two rows as input, applies the rules to them one by one, and returns a Boolean value indicating whether a match was found and the index of the matching rule.

    Read in the first Excel sheet into a pandas DataFrame called T5_table.

python

T5_table = pd.read_excel('Z:/Downloads/Unmatched_trans_Data_1.xlsx', dtype=str)

    Read in the second Excel sheet into a pandas DataFrame called Invoice_table.

python

Invoice_table = pd.read_excel('Z:/Downloads/Unmatched_Inv_Data_1.xlsx', dtype=str)

    Create an empty list called output_data to store the matched rows, and a dictionary called rule_descriptions to store the descriptions of the matching rules.

python

output_data = []
rule_descriptions = {
    1: 'Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same',
    2: 'Ticket_no_right_of_12'
}

    Loop through each row in T5_table, find a match in Invoice_table using the match_row function, and append the matched row along with the rule index and description to the output_data list.

python

for i, T5 in T5_table.iterrows():
    matched = False
    for j, Invoice in Invoice_table.iterrows():
        matched, rule_index = match_row(T5.to_dict(), Invoice.to_dict())
        if matched:
            description = rule_descriptions[rule_index]
            output_data.append([T5['Company ID & Name'], rule_index, description, T5['fin_orig_supplier_nm'], T5['fin_source_amt'], Invoice['inv_match_source_amt'], Invoice['inv_erp_vend_no'], Invoice['inv_po_no']])
            break

    Create a pandas DataFrame called output_df from the output_data list, add a column called "TRF" to store the number of rows matched for each company and rule, and write the output to an Excel file called output2.xlsx.

python

output_columns = ['Company ID & Name', 'Match Rule', 'description', 'fin_orig_supplier_nm', 'fin_source_amt', 'inv_match_source_amt', 'inv_erp_vend_no', 'inv_po_no']
output_df = pd.DataFrame(output_data, columns=output_columns)
aggregated


The code performs a matching process between two Excel tables, T5_table and Invoice_table, and generates an output file with the matched rows along with a rule index and description. Here is a step-by-step explanation of the code:





    Test with sample input files: You can create small sample input Excel files with a few rows and columns and test the code to see if it produces the expected output.

    Test with different rule sets: You can create different rule sets in a text file and test the code with each rule set to see if it produces the expected output.

    Test with missing data: You can remove some data from the input files and test the code to see how it handles missing data.

    Test with different data types: You can test the code with input files that have different data types (e.g., integers, floats, dates, strings) to see if it handles them correctly.

    Test with larger input files: You can test the code with larger input files to see if it can handle them efficiently without crashing or running out of memory.

    Test with edge cases: You can test the code with edge cases, such as input files that have many duplicates, or rules that match only a small subset of the data, to see if it produces the expected output.

    Test with invalid input files: You can test the code with invalid input files, such as files that are not in the expected format, to see how it handles errors and exceptions.








from pyspark.sql import SparkSession
from pyspark.sql.functions import udf
from pyspark.sql.types import BooleanType, IntegerType, StringType
import pandas as pd

# Initialize SparkSession
spark = SparkSession.builder.appName("Matching").getOrCreate()

# Define UDFs to convert row dictionaries to DataFrame rows
row_dict_to_row = udf(lambda d: tuple(d.values()), StringType())
row_dict_to_row2 = udf(lambda d: tuple(d.values()), StringType())

# Read the rules from a text file
with open("Z:/Desktop/Rules_1.txt", 'r') as f:
    rule_strings = f.readlines()

# Remove new line characters and empty lines, and convert to list of functions
rules = []
for rule_string in rule_strings:
    rule_string = rule_string.strip()
    if rule_string:
        rule = eval(f"lambda row, row2: {rule_string}")
        rules.append(rule)

# Define a UDF to apply the rules to each row pair and return the rule index
match_row_udf = udf(lambda T5, Invoice: match_row(T5, Invoice, rules), (BooleanType(), IntegerType()))

# Define a function to apply the rules to each row pair and return the rule index
def match_row(T5, Invoice, rules):
    for i, rule in enumerate(rules):
        if rule(T5, Invoice):
            return True, i+1
    return False, "Unmatched"

# Read in the two Excel sheets as PySpark DataFrames
T5_table = spark.read.format("com.crealytics.spark.excel") \
    .option("header", "true") \
    .option("inferSchema", "true") \
    .option("dataAddress", "'Sheet1$'") \
    .load("Z:/Downloads/Unmatched_trans_Data_1.xlsx")
Invoice_table = spark.read.format("com.crealytics.spark.excel") \
    .option("header", "true") \
    .option("inferSchema", "true") \
    .option("dataAddress", "'Sheet1$'") \
    .load("Z:/Downloads/Unmatched_Inv_Data_1.xlsx")

# Apply the UDF to each row pair and select the matching rows
matched_rows = T5_table.crossJoin(Invoice_table) \
    .withColumn("matched", match_row_udf(row_dict_to_row(T5_table), row_dict_to_row2(Invoice_table))) \
    .filter("matched[0] == true") \
    .select(T5_table["Company ID & Name"], "matched[1]", T5_table["fin_orig_supplier_nm"], T5_table["fin_source_amt"], Invoice_table["inv_match_source_amt"], Invoice_table["inv_erp_vend_no"], Invoice_table["inv_po_no"])

# Create a Pandas DataFrame from the matched rows
output_df = matched_rows.toPandas()

# Add a column for the rule description
output_df["description"] = output_df["matched[1]"].map({1: "Ticket_no_right_of_13, Acct_no, Amount, Currency, Date, C&D indicator, RPIC are same", 2: "Ticket_no_right_of_12"})

# Group the output by Company ID & Name and Match Rule and count the number of rows
aggregated = output_df.groupby(["Company ID & Name", "matched[1]"]).size().reset_index(name="TRF")
total = aggregated["TRF"].sum()

# Add a row for the total
aggregated = aggregated.append(pd.Series(["Total", "-", total], index=
