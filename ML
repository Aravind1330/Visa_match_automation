import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder
from sklearn import preprocessing

# Load the data
data = pd.read_csv('invoices_transactions.csv')

# Preprocess the data
# Assuming you have two columns: 'invoice_text' and 'transaction_text'
# Preprocessing involves cleaning and transforming the text data
# You can use techniques like removing punctuation, lowercasing, tokenization, etc.

# Split the data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(
    data['invoice_text'], data['transaction_text'], test_size=0.2, random_state=42)

# Vectorize the text data
vectorizer = TfidfVectorizer()
X_train_vectorized = vectorizer.fit_transform(X_train)
X_test_vectorized = vectorizer.transform(X_test)

# Train a logistic regression classifier
classifier = LogisticRegression()
classifier.fit(X_train_vectorized, y_train)

# Predict on the test set
predictions = classifier.predict(X_test_vectorized)

# Evaluate the model
accuracy = accuracy_score(y_test, predictions)
print(f"Accuracy: {accuracy}")

# Match new invoices with transactions
new_invoices = [
    "Invoice 1 text",
    "Invoice 2 text",
    "Invoice 3 text"
]

# Vectorize the new invoice text
new_invoices_vectorized = vectorizer.transform(new_invoices)

# Predict the matching transactions for new invoices
predicted_transactions = classifier.predict(new_invoices_vectorized)

# Print the predicted transactions
for invoice, transaction in zip(new_invoices, predicted_transactions):
    print(f"Invoice: {invoice} - Predicted Transaction: {transaction}")










import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load your transaction and invoice data into pandas DataFrames
transaction_data = pd.read_csv('transaction_data.csv')
invoice_data = pd.read_csv('invoice_data.csv')

# Select relevant columns for matching
transaction_features = transaction_data['supplier_name'].astype(str)
invoice_features = invoice_data['ticket_number'].astype(str).str[:5]

# Preprocess data and create feature vectors
vectorizer = TfidfVectorizer()
transaction_vectors = vectorizer.fit_transform(transaction_features)
invoice_vectors = vectorizer.transform(invoice_features)

# Compute cosine similarity between transaction and invoice vectors
similarity_matrix = cosine_similarity(transaction_vectors, invoice_vectors)

# Find the best matches
threshold = 0.8  # Adjust the threshold based on your needs
matches = []
for transaction_idx, row in enumerate(similarity_matrix):
    best_match_idx = row.argmax()
    best_match_score = row[best_match_idx]
    if best_match_score >= threshold:
        transaction_id = transaction_data.iloc[transaction_idx]['transaction_id']
        invoice_id = invoice_data.iloc[best_match_idx]['invoice_id']
        matches.append((transaction_id, invoice_id, best_match_score))

# Display the matches
for transaction_id, invoice_id, score in matches:
    print(f"Match found: Transaction ID {transaction_id} -> Invoice ID {invoice_id}, Score: {score}")





# Display and save the matches
output_file = 'matches.csv'
with open(output_file, 'w') as file:
    file.write("Transaction ID, Invoice ID, Score\n")
    for transaction_id, invoice_id, score in matches:
        print(f"Match found: Transaction ID {transaction_id} -> Invoice ID {invoice_id}, Score: {score}")
        file.write(f"{transaction_id}, {invoice_id}, {score}\n")

print(f"Matches saved to {output_file}")











import pandas as pd
from fuzzywuzzy import fuzz

# Load your transaction and invoice data into pandas DataFrames
transaction_data = pd.read_csv('transaction_data.csv')
invoice_data = pd.read_csv('invoice_data.csv')

# Select relevant columns for matching
transaction_features = transaction_data['supplier_name'].astype(str)
invoice_features = invoice_data['ticket_number'].astype(str).str[:5]

# Find the best matches
threshold = 80  # Adjust the threshold based on your needs
matches = []
for transaction_idx, transaction_name in enumerate(transaction_features):
    best_match_score = -1
    best_match_idx = -1
    for invoice_idx, invoice_name in enumerate(invoice_features):
        similarity_score = fuzz.ratio(transaction_name, invoice_name)
        if similarity_score > best_match_score:
            best_match_score = similarity_score
            best_match_idx = invoice_idx

    if best_match_score >= threshold:
        transaction_id = transaction_data.iloc[transaction_idx]['transaction_id']
        invoice_id = invoice_data.iloc[best_match_idx]['invoice_id']
        matches.append((transaction_id, invoice_id, best_match_idx, best_match_score))

# Display and save the matches
output_file = 'matches.csv'
with open(output_file, 'w') as file:
    file.write("Transaction ID, Invoice ID, Best Match Index, Score\n")
    for match in matches:
        file.write(f"{match[0]}, {match[1]}, {match[2]}, {match[3]}\n")
        print(f"Match found: Transaction ID {match[0]} -> Invoice ID {match[1]}, Best Match Index: {match[2]}, Score: {match[3]}")

print(f"Matches saved to {output_file}")









import pandas as pd
from fuzzywuzzy import fuzz

# Load your transaction and invoice data into pandas DataFrames
transaction_data = pd.read_csv('transaction_data.csv')
invoice_data = pd.read_csv('invoice_data.csv')

# Select relevant columns for matching
transaction_features = transaction_data['supplier_name'].astype(str)
invoice_features = invoice_data['ticket_number'].astype(str).str[:5]

# Create a set to store matched invoice indices
matched_indices = set()

# Find the best matches
threshold = 80  # Adjust the threshold based on your needs
matches = []
for transaction_idx, transaction_name in enumerate(transaction_features):
    best_match_score = -1
    best_match_idx = -1
    for invoice_idx, invoice_name in enumerate(invoice_features):
        if invoice_idx not in matched_indices:  # Check if the invoice has already been matched
            similarity_score = fuzz.ratio(transaction_name, invoice_name)
            if similarity_score > best_match_score:
                best_match_score = similarity_score
                best_match_idx = invoice_idx

    if best_match_score >= threshold:
        transaction_id = transaction_data.iloc[transaction_idx]['transaction_id']
        invoice_id = invoice_data.iloc[best_match_idx]['invoice_id']
        matches.append((transaction_id, invoice_id, best_match_idx, best_match_score))
        matched_indices.add(best_match_idx)  # Add the matched invoice index to the set

# Display and save the matches
output_file = 'matches.csv'
with open(output_file, 'w') as file:
    file.write("Transaction ID, Invoice ID, Best Match Index, Score\n")
    for match in matches:
        file.write(f"{match[0]}, {match[1]}, {match[2]}, {match[3]}\n")
        print(f"Match found: Transaction ID {match[0]} -> Invoice ID {match[1]}, Best Match Index: {match[2]}, Score: {match[3]}")

print(f"Matches saved to {output_file}")

















import pandas as pd
from fuzzywuzzy import fuzz

# Load your transaction and invoice data into pandas DataFrames
transaction_data = pd.read_csv('transaction_data.csv')
invoice_data = pd.read_csv('invoice_data.csv')

# Select relevant columns for matching
transaction_features = transaction_data['supplier_name'].astype(str)
invoice_features = invoice_data['ticket_number'].astype(str).str[:5]

# Create a set to store matched invoice indices
matched_indices = set()

# Find the best matches
threshold = 80  # Adjust the threshold based on your needs
matches = []
for transaction_idx, transaction_name in enumerate(transaction_features):
    best_match_score = -1
    best_match_idx = -1
    for invoice_idx, invoice_name in enumerate(invoice_features):
        if invoice_idx not in matched_indices:  # Check if the invoice has already been matched
            for i in range(len(transaction_name)-4):
                substring = transaction_name[i:i+5]
                similarity_score = fuzz.ratio(substring, invoice_name)
                if similarity_score > best_match_score:
                    best_match_score = similarity_score
                    best_match_idx = invoice_idx

    if best_match_score >= threshold:
        transaction_id = transaction_data.iloc[transaction_idx]['transaction_id']
        invoice_id = invoice_data.iloc[best_match_idx]['invoice_id']
        matches.append((transaction_id, invoice_id, best_match_idx, best_match_score))
        matched_indices.add(best_match_idx)  # Add the matched invoice index to the set

# Display and save the matches
output_file = 'matches.csv'
with open(output_file, 'w') as file:
    file.write("Transaction ID, Invoice ID, Best Match Index, Score\n")
    for match in matches:
        file.write(f"{match[0]}, {match[1]}, {match[2]}, {match[3]}\n")
        print(f"Match found: Transaction ID {match[0]} -> Invoice ID {match[1]}, Best Match Index: {match[2]}, Score: {match[3]}")

print(f"Matches saved to {output_file}")













import pandas as pd
from fuzzywuzzy import fuzz

# Load your transaction and invoice data into pandas DataFrames
transaction_data = pd.read_csv('transaction_data.csv')
invoice_data = pd.read_csv('invoice_data.csv')

# Select relevant columns for matching
transaction_features = transaction_data['supplier_name'].astype(str)
invoice_features = invoice_data['ticket_number'].astype(str).str[:5]

# Create a set to store matched invoice indices
matched_indices = set()

# Find the best matches
threshold = 80  # Adjust the threshold based on your needs
matches = []
for transaction_idx, transaction_name in enumerate(transaction_features):
    best_match_score = -1
    best_match_idx = -1
    best_match_pattern = ""
    for invoice_idx, invoice_name in enumerate(invoice_features):
        if invoice_idx not in matched_indices:  # Check if the invoice has already been matched
            for i in range(len(transaction_name) - 4):
                substring = transaction_name[i:i + 5]
                similarity_score = fuzz.ratio(substring, invoice_name)
                if similarity_score > best_match_score:
                    best_match_score = similarity_score
                    best_match_idx = invoice_idx
                    best_match_pattern = f"{transaction_name} -> {substring} = {invoice_name}"

    if best_match_score >= threshold:
        transaction_id = transaction_data.iloc[transaction_idx]['transaction_id']
        invoice_id = invoice_data.iloc[best_match_idx]['invoice_id']
        matches.append((transaction_id, invoice_id, best_match_idx, best_match_score, best_match_pattern))
        matched_indices.add(best_match_idx)  # Add the matched invoice index to the set

# Display and save the matches
output_file = 'matches.csv'
with open(output_file, 'w') as file:
    file.write("Transaction ID, Invoice ID, Best Match Index, Score, Matched Pattern\n")
    for match in matches:
        file.write(f"{match[0]}, {match[1]}, {match[2]}, {match[3]}, {match[4]}\n")
        print(f"Match found: Transaction ID {match[0]} -> Invoice ID {match[1]}, "
              f"Best Match Index: {match[2]}, Score: {match[3]}, Matched Pattern: {match[4]}")

print(f"Matches saved to {output_file}")










# Convert unmatched invoices to DataFrame and write to CSV
unmatched_output_df = pd.DataFrame(unmatched_invoices)
unmatched_output_df.to_csv('Z:/Desktop/unmatched_output.csv', index=False)
























import pandas as pd
import yaml

# Read the rules from the CSV file
rules_df = pd.read_csv('Z:/Desktop/Rules.csv')
rules = []
rule_descriptions = {}
for i, row in rules_df.iterrows():
    rule_string = row['Rule']
    rule_description = row['Description']
    rule = eval(f"lambda row, row2: {rule_string}")
    rules.append(rule)
    rule_descriptions[i+1] = rule_description

match_row (TS, Invoice table):
    matching_invoices = []
    total_invoice_source_amt = 0
    match_rule = None
    for i, Invoice in enumerate(Invoice_table):
        for rule_index, rule in enumerate(rules, start=1):
            if rule(rowsT5, Invoice=Invoice):
                matching_invoices.append((Invoice, i + 1))
                total_invoice_source_amt += Invoice['inv_match_source_amt']
                match_rule = rule_index
                break
        if total_invoice_source_amt == T5['fin_source_amt']:
            return matching_invoices, match_rule
    return matching_invoices, None

# Read the config file
with open('config.yml', 'r') as f:
    config = yaml.safe_load(f)

# Define the output columns
output_columns = config['output_columns']

# Define a list to store the output rows
output_rows = []

# Define a list to store the unmatched transactions
unmatched_output_columns = config['unmatched_output_columns']
unmatched_output_rows = []

# Process each T5 transaction
for T5 in T5_table:
    matching_invoices, match_rule = match_row(T5, Invoice_table)
    match_type = "one-to-one" if len(matching_invoices) == 1 else "bundle match"

    if matching_invoices:
        for invoice, rule_index in matching_invoices:
            description = rule_descriptions.get(rule_index)
            output_row = {
                column: T5[column] if column in T5 else invoice[column] for column in output_columns
            }
            output_row['Match Rule'] = rule_index
            output_row['Description'] = description
            output_row['Match Type'] = match_type
            output_rows.append(output_row)
            # Remove the matched transaction from unmatched_output_df
            unmatched_indices = unmatched_output_df[
                (unmatched_output_df['fin_record_key'] == T5['fin_record_key']) & 
                (unmatched_output_df['fin_source_amt'] == T5['fin_source_amt'])
            ].index
            unmatched_output_df.drop(unmatched_indices, inplace=True)
    else:
        unmatched_output_row = {
            column: T5[column] if column in T5 else None for column in unmatched_output_columns
        }
        unmatched_output_rows.append(unmatched_output_row)

# Create a DataFrame from the output rows
output_df = pd.DataFrame(output_rows, columns=output_columns)

# Create a DataFrame from the unmatched output rows
unmatched_output_df = pd.DataFrame(unmatched_output_rows, columns=unmatched_output_columns)

# Write the output data to a CSV file
output_df.to_csv('Z:/Desktop/output.csv', index=False)

# Save unmatched transactions to a separate CSV file
unmatched_transactions_file = 'Z:/Desktop/unmatched_transactions.csv'
unmatched_output_df.to_csv(unmatched_transactions_file, index=False)

# Save unmatched invoices to a separate CSV file
unmatched_invoices_file = 'Z:/Desktop/unmatched_invoices.csv'
unmatched_invoices_df.to_csv(unmatched_invoices_file, index=False)

# Write the aggregated data to Excel
aggregated = None  # Assuming aggregated data is defined elsewhere
with pd.ExcelWriter(config['output_file']) as writer:
    output_df.to_excel(writer, sheet_name='Output', index=False)
    aggregated.to_excel(writer, sheet_name='Aggregated', index=False)








import pandas as pd
from fuzzywuzzy import fuzz

# Load your transaction and invoice data into pandas DataFrames
transaction_data = pd.read_csv('transaction_data.csv')
invoice_data = pd.read_csv('invoice_data.csv')

# Select relevant columns for matching
transaction_features = transaction_data['supplier_name'].astype(str)
invoice_features = invoice_data['ticket_number'].astype(str).str[:5]

# Create a set to store matched invoice indices
matched_indices = set()

# Find the best matches
threshold = 80  # Adjust the threshold based on your needs
matches = []
for transaction_idx, transaction_name in enumerate(transaction_features):
    best_match_score = -1
    best_match_idx = -1
    best_match_pattern = ""
    for invoice_idx, invoice_name in enumerate(invoice_features):
        if invoice_idx not in matched_indices:  # Check if the invoice has already been matched
            for column_name, column_value in transaction_data.iterrows():
                column_value = str(column_value[1])
                for i in range(len(column_value) - 4):
                    substring = column_value[i:i + 5]
                    similarity_score = fuzz.ratio(substring, invoice_name)
                    if similarity_score > best_match_score:
                        best_match_score = similarity_score
                        best_match_idx = invoice_idx
                        best_match_pattern = f"Matched Pattern: {column_name} = {column_value}"
                        break  # Break the inner loop if a match is found in any of the columns

    if best_match_score >= threshold:
        transaction_id = transaction_data.iloc[transaction_idx]['transaction_id']
        invoice_id = invoice_data.iloc[best_match_idx]['invoice_id']
        matches.append((transaction_id, invoice_id, best_match_idx, best_match_score, best_match_pattern))
        matched_indices.add(best_match_idx)  # Add the matched invoice index to the set

# Display and save the matches
output_file = 'matches.csv'
with open(output_file, 'w') as file:
    file.write("Transaction ID, Invoice ID, Best Match Index, Score, Matched Pattern\n")
    for match in matches:
        file.write(f"{match[0]}, {match[1]}, {match[2]}, {match[3]}, {match[4]}\n")
        print(f"Match found: Transaction ID {match[0]} -> Invoice ID {match[1]}, "
              f"Best Match Index: {match[2]}, Score: {match[3]}, {match[4]}")

print(f"Matches saved to {output_file}")


threshold = 80  # Adjust the threshold based on your needs
matches = []
for transaction_idx, transaction_row in transaction_features.iterrows():
    best_match_score = -1
    best_match_idx = -1
    best_match_pattern = ""
    for invoice_idx, invoice_name in enumerate(invoice_features):
        if invoice_idx not in matched_indices:  # Check if the invoice has already been matched
            for column_name, column_value in transaction_row.iteritems():
                for i in range(len(column_value) - 4):
                    substring = column_value[i:i + 5]
                    similarity_score = fuzz.ratio(substring, invoice_name)
                    if similarity_score > best_match_score:
                        best_match_score = similarity_score
                        best_match_idx = invoice_idx
                        best_match_pattern = f"Matched Pattern: {column_name} = {column_value}"
                        break  # Break the inner loop if a match is found in any of the columns

    if best_match_score >= threshold:
        transaction_id = transaction_data.iloc[transaction_idx]['transaction_id']
        invoice_id = invoice_data.iloc[best_match_idx]['invoice_id']
        matches.append((transaction_id, invoice_id, best_match_idx, best_match_score, best_match_pattern))
        matched_indices.add(best_match_idx)  # Add the matched invoice index to the set
