    for i, Invoice in enumerate(Invoice_table):
        if Invoice['matched']:
            continue  # Skip the invoice if already matched
        for rule_index, rule in enumerate(rules, start=1):
            if rule(T5, Invoice=Invoice):  # Updated to use 'Invoice' as a keyword argument
                matching_invoices.append((Invoice, i + 1))
                total_invoice_source_amt += Invoice['inv_match_source_amt']
                match_rule = rule_index
                # Store the rule number when a match occurs
                Invoice_table[i]['matched'] = True  # Mark the invoice as matched
                break

    if total_invoice_source_amt == T5['fin_source_amt']:
        return matching_invoices, match_rule
    # Return the matching invoices and rule number
    return [], None










            matched_invoices.append(invoice)  # Add matched invoice to the list
    # Remove the matched invoices from Invoice_table
    for matched_invoice in matched_invoices:
        Invoice_table.remove(matched_invoice)




# Create a DataFrame from the unmatched invoices
unmatched_invoices_df = pd.DataFrame(unmatched_invoices)

# Write the unmatched invoices to a separate CSV file
unmatched_invoices_df.to_csv(unmatched_invoices_file, index=False)










# Process each T5 transaction
for T5 in T5_table:
    matching_invoices, match_rule = match_row(T5, Invoice_table)
    match_type = "one-to-one" if len(matching_invoices) == 1 else "bundle match"

    if matching_invoices:
        for invoice, rule_index in matching_invoices:
            description = rule_descriptions.get(rule_index)
            output_row = {column: T5[column] if column in T5 else invoice[column] for column in output_columns}
            output_row['Match Rule'] = rule_numbers.get(match_rule)
            output_row['description'] = description
            output_row['Match Type'] = match_type
            output_rows.append(output_row)
            matched_invoices.append(invoice)

            if match_type == "one-to-one":
                unmatched_indices = unmatched_output_df[
                    (unmatched_output_df['fin_record_key'] == T5['fin_record_key']) &
                    (unmatched_output_df['fin_source_amt'] == T5['fin_source_amt']) &
                    (unmatched_output_df['fin_credit_debit_ind'] == T5['fin_credit_debit_ind'])
                ].index
            else:
                unmatched_indices = unmatched_output_df[
                    (unmatched_output_df['fin_record_key'] == T5['fin_record_key']) &
                    (unmatched_output_df['fin_source_amt'] == T5['fin_source_amt'])
                ].index
            unmatched_output_df.drop(unmatched_indices, inplace=True)
    else:
        unmatched_output_row = {column: T5[column] if column in T5 else None for column in unmatched_output_columns}
        unmatched_invoice_rows.append(unmatched_output_row)
        unmatched_transaction_rows.append(unmatched_output_row)

    for matched_invoice in matched_invoices:
        Invoice_table.remove(matched_invoice)



unmatched_invoice_df = pd.DataFrame(unmatched_invoice_rows, columns=unmatched_output_columns)
unmatched_transaction_df = pd.DataFrame(unmatched_transaction_rows, columns=unmatched_output_columns)

unmatched_invoice_df.to_csv(unmatched_invoice_output_file, index=False)
unmatched_transaction_df.to_csv(unmatched_transaction_output_file, index=False)
# Define the paths for the unmatched output files
unmatched_invoice_output_file = 'Z:/Desktop/Automation_output/Unmatched_Invoices.csv'
unmatched_transaction_output_file = 'Z:/Desktop/Automation_output/Unmatched_Transactions.csv'






        matched_count += 1
        
        # Print the count of matched transactions at desired intervals
        if matched_count % 100 == 0:
            print(f"Matched Transactions: {matched_count}")


# Remove the matched invoices from the Invoice_table list
Invoice_table = [invoice for invoice in Invoice_table if invoice not in matched_invoices]




# Collect all unmatched invoices from the Invoice_table
for unmatched_invoice in Invoice_table:
    unmatched_invoice_row = {column: unmatched_invoice[column] for column in unmatched_output_columns}
    unmatched_invoice_rows.append(unmatched_invoice_row)




# Process each T5 transaction
for T5 in T5_table:
    matching_invoices, match_rule = match_row(T5, Invoice_table)
    match_type = "one-to-one" if len(matching_invoices) == 1 else "bundle match"

    if matching_invoices:
        for invoice, rule_index in matching_invoices:
            description = rule_descriptions.get(rule_index)
            output_row = {column: T5[column] if column in T5 else invoice[column] for column in output_columns}
            output_row['Match Rule'] = rule_numbers.get(match_rule)  # Add the rule number to the output row
            output_row['description'] = description
            output_row['Match Type'] = match_type  # Add the match type to the output row
            output_rows.append(output_row)
            matched_invoices.append(invoice)  # Add matched invoice to the list

            # Remove the matched invoice from Invoice_table
            Invoice_table.remove(invoice)

            # Remove the matched transaction from unmatched_output_df
            if match_type == "one-to-one":
                unmatched_indices = unmatched_output_df[
                    (unmatched_output_df['fin_record_key'] == T5['fin_record_key']) &
                    (unmatched_output_df['fin_source_amt'] == T5['fin_source_amt']) &
                    (unmatched_output_df['fin_credit_debit_ind'] == T5['fin_credit_debit_ind'])
                ].index
            else:
                unmatched_indices = unmatched_output_df[
                    (unmatched_output_df['fin_record_key'] == T5['fin_record_key']) &
                    (unmatched_output_df['fin_source_amt'] == T5['fin_source_amt'])
                ].index
            unmatched_output_df.drop(unmatched_indices, inplace=True)
    else:
        unmatched_output_row = {column: T5[column] if column in T5 else None for column in unmatched_output_columns}
        unmatched_output_rows.append(unmatched_output_row)

# Rest of the code remains unchanged










import pandas as pd
import yaml

# Rest of the code...

def match_row(T5, Invoice_table):
    matching_invoices = []
    total_invoice_source_amt = 0
    match_rule = None

    for i, Invoice in enumerate(Invoice_table):
        for rule_index, rule in enumerate(rules, start=1):
            if rule(T5, Invoice=Invoice):
                matching_invoices.append((Invoice, i + 1))
                total_invoice_source_amt += Invoice['inv_match_source_amt']
                match_rule = rule_index
                break

    if total_invoice_source_amt == T5['fin_source_amt']:
        return matching_invoices, match_rule
    return [], None


# Process each T5 transaction
for T5 in T5_table:
    # Check if any match value starts with 0
    match_starts_with_zero = any(str(value).startswith('0') for value in T5.values())

    if match_starts_with_zero:
        # Adjust the matching rules to handle values starting with 0
        def match_rule(T5, Invoice):
            # Assuming the field to compare is 'field_name' in both T5 and Invoice
            t5_value = str(T5['field_name'])
            invoice_value = str(Invoice['field_name'])

            # Compare values after removing leading zeros
            if t5_value.lstrip('0') == invoice_value.lstrip('0'):
                return True
            else:
                return False

    matching_invoices, match_rule = match_row(T5, Invoice_table)
    
    # Rest of the code...





rule = lambda row, row2: str(eval(rule_string)).zfill(len(str(row['fin_source_amt']))) == str(row2['inv_match_source_amt']).zfill(len(str(row['fin_source_amt'])))
    
    
    
    
    
    
def compare_values(value1, value2):
    """
    Compare two values, handling leading zeros for numeric values.
    """
    if isinstance(value1, (int, float)) and isinstance(value2, (int, float)):
        value1 = str(value1)
        value2 = str(value2)
        if value1.startswith('0') or value2.startswith('0'):
            return value1 == value2  # Compare as strings if either value has leading zeros
    return value1 == value2


def match_row(T5, Invoice_table):
    matching_invoices = []
    total_invoice_source_amt = 0
    match_rule = None  # Initialize the match_rule variable

    for i, Invoice in enumerate(Invoice_table):
        for rule_index, rule in enumerate(rules, start=1):
            if rule(T5, Invoice=Invoice, compare_values=compare_values):  # Pass compare_values function as an argument
                matching_invoices.append((Invoice, i + 1))
                total_invoice_source_amt += Invoice['inv_match_source_amt']
                match_rule = rule_index
                # Store the rule number when a match occurs
                break

    if total_invoice_source_amt == T5['fin_source_amt']:
        return matching_invoices, match_rule
    # Return the matching invoices and rule number
    return [], None



rule = lambda row, row2: str(row['column_name']).zfill(10) == str(row2['column_name']).zfill(10)  # Adjust 'column_name' to the relevant column name
